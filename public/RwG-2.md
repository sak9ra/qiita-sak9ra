
---
title: [Rust] 可変参照の基本と参照スコープ [Rust初心者がGPTと学ぶ Day 2] 
tags:
  - 'Rust'
  - '100DaysOfCode'
  - '初心者'
private: true
updated_at: ''
id: null
organization_url_name: null
slide: false
ignorePublish: false
---

## ChatGPTとRust No.2

### 本シリーズについて

ChatGPTにRustの課題を出してもらい、初学者の筆者が回答 → 解説 →反省 という流れで学んでいくシリーズです。  詳細は本記事末尾の[補足・詳細](#補足詳細)をご覧ください。
ChatGPTにRustに関する問題を出題してもらい、それに回答する形式で学習します。

:::note warn
ChatGPT+プログラミング初学者による記事ですので誤った内容を含む可能性があります。
:::

**本シリーズ記事の目次**
- [課題](#課題by-chatgpt)
- [回答・解説](#回答解説)
- [筆者の回答・採点結果](#筆者の回答採点結果)
  
## 課題（by ChatGPT）
難易度：基礎
想定時間：15〜30分

問題
以下のコードはコンパイルエラーになります。エラーの原因を説明し、正しく動作するように修正してください。

```rust: problem.rs
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s;

    println!("{}, {}", r1, r2);
}
```
### 課題内容
1. 上記コードがコンパイルエラーになる理由を説明してください
2. Rust における「同時に複数の可変参照が禁止される理由」について、メモリ安全性の観点から説明してください
3. このプログラムを安全に動作させるための修正版を提示してください
4. 参照スコープの開始と終了について、Rust コンパイラがどのように判断しているかを簡潔に説明してください。


---
## 解答・解説

#### 課題1. コンパイルエラーの原因

```rust
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> src/main.rs:4:13
  |
3 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
4 |     let r2 = &mut s;
  |             ^^^^^^ second mutable borrow occurs here
5 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here
```

**理由**
let r1 = &mut s; で s を可変借用（&mut s）すると、借用が解放されるまで s に対する他の借用（可変／不変）を禁止します。r1 が有効なスコープ内で再度 let r2 = &mut s; を書くと、「同一データへの複数の可変参照」が発生するためコンパイルエラーになります。

### 課題2. 可変参照の排他性の意義（メモリ安全性の観点）

- **データ競合 (Data Race) の防止**
複数の可変参照が同時に存在すると、同一メモリ地点への同時書き込みが起こり得ます。C/C++ 等ではこれが実行時の未定義動作につながることがあり、デバッグが非常に困難になります。

- **ダングリング参照の回避**
可変参照経由でデータを再割当・破棄した場合に、別の参照が「既に無効なメモリ」を指し続ける恐れがあります。

- **Rust の保証**
Rust はコンパイル時にこれらを排除し、安全なメモリアクセスを強力に担保します。

### 課題3. 修正版コード例

```rust: ブロックで可変借用のスコープを分離
fn main() {
    let mut s = String::from("hello");

    {
        // r1 のスコープ
        let r1 = &mut s;
        println!("r1 = {}", r1);
    } // ← r1 の借用終了

    {
        // r2 のスコープ
        let r2 = &mut s;
        println!("r2 = {}", r2);
    } // ← r2 の借用終了
}

```

```rust: 可変参照ではなく不変参照を複数持つ
fn main() {
    let mut s = String::from("hello");
    let r1 = &s;
    let r2 = &s;
    // 不変参照は複数同時に許可される
    println!("{}, {}", r1, r2);
}

```

### 課題4. 参照スコープの開始と終了の認識

- **Non–Lexical Lifetimes (NLL)**
Rust では、借用の有効期間を「変数のブロックスコープ」ではなく「最後に参照を使用した位置」をもとに自動的に短縮します。
<br>

- **ブロックによる明示制御**
`{ … }` で局所的に借用を囲むと、コンパイラはそのブロック終端で借用が切れるとみなし、以降で再度借用が可能になります。
<br>

- **参照開始**
参照式（&mut s や &s）が評価される箇所
<br>

- **参照終了**
その参照オブジェクトが最後に使われた式の終了時点（またはブロック終端）

---
参考リンク

[the book -参照と借用-](https://doc.rust-jp.rs/book-ja/ch04-02-references-and-borrowing.html)

---

## 筆者の回答・採点結果

### コンパイルエラーの理由
１つの変数に対して可変参照は一度に１つしか作成できないから。r1という可変参照が有効なスコープでr2という新たな可変参照を宣言しているのでエラーが発生している。

### メモリ安全性の観点から説明
複数の可変参照が存在すると、複数の変数を通じて同じメモリ領域を書き換えることができることになる。しかし、このような状況では値の書き換えのタイミングなどの管理が複雑化し、意図しない書き換えが発生する可能性が増大する。

:::note warn
ダングリングポインタの存在を忘れていました...
:::

### プログラムの修正版

```diff_rust: fixed.rs
diff_rust: fixed.rs
fn main() {
    let mut s = String::from("hello");

-    let r1 = &mut s; 
-    let r2 = &mut s; 
+   let r1 = &s;
+   let r2 = &s;

    println!("{}, {}", r1, r2);
}
```

### :x:　参照スコープの開始と終了について

参照が宣言された時点が参照スコープの開始で、その参照が通常の変数同様にスコープを抜けたタイミングが参照スコープの終了である。

:::note alert
借用は最後に評価されたタイミングで参照スコープが終了するということを理解できていませんでした。
:::


## 補足・詳細

### 環境

- ChatGPT-4o-mini-high
タスク機能に以下のように指示をしています

``` :タスク指示

毎朝5時に、Rustの幅広い要素を系統的に習得するため、まずは基礎トピックをすべてマスターできるように
設計された、15〜30分で取り組めるクイズ、調査テーマ、またはコーディング問題を出してください。  
基礎が理解できた後に応用内容へステップアップするよう成長度合いに合わせて難易度を調整し、各課題には
採点と詳細な解説を含めてください。

```

- Rust 
version : 常にstableを使用（投稿時点で1.87.0）


## 参考

https://doc.rust-jp.rs/book-ja/ch04-02-references-and-borrowing.html

